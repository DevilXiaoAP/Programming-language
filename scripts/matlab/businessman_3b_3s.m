%businessman_3b_3s.m   ――商人过河MATLAB程序，3商人，3仆人
%本程序相对于网上各种结构体，堆栈形式的程序来说简单很多，没有用到那些高级的函数，简单易懂
%核心要点（1）就是巧妙地将z(a,b)加上了c变成(a,b,c),c用来判断此时船的行进方向，在后面判断是否有重复时非常重要，因为在船行进方向不同时，就算此岸人员分布一样也不是一种情况
%核心要点（2）就是设置了m数组，以便于在后面的穷举过程中，记录每一步所采用的决策方案，以防止后面重复或者遗漏
%核心要点（3）成功找出所有可能的情况，相对于网络上只能找出一种有效情况来说是个巨大的进步
clear all
clc

z=zeros(30,3);      %z为由(a,b,c)的列向量组成的3行30列数组，初始化为0矩阵，a,b,c代表此刻此岸的商人，仆人数量以及船的运行状态，c=1表示即将向彼岸运行
m=zeros(1,20);      %m为一维行向量，初始化为1矩阵，用于在后面的程序中判断第k次选择的乘船方案
d=[0,1,1;0,2,1;1,0,1;1,1,1;2,0,1];  %共有5种可以选择的乘船方案，最后面一列全为1，即用于在后面表示使得z(k,3)的取值保持随着k的奇偶性保持着0-1变换.
z(1,:)=[3,3,1];                     %初始状态为[3,3,1]
k=1;
m(k)=1;                             %第一次默认的乘船方案为决策1――d(1)
flag=1;                             %用于在后面判断是否成功找到方案
answer=0;                           %用于在后面判断是否找到答案  
while k>0                           %保持k>0
    if m(k)>5
        flag=0;
        break;
    end
    p=0;
    z(k+1,:)=z(k,:)+(-1)^k*d(m(k),:);  %每一次的运算规则都是z(k+1)=z(k)-(-1)^k*d(m(k),:),d(m(k),:)表示决策方案
    a=z(k+1,1);                        %将当前情况的矩阵数值复制给a商人,b仆人
    b=z(k+1,2);
    c=z(k+1,3); 
    if (a==3&&(b==0||b==1||b==2||b==3))||(a==1&&b==1)||(a==2&&b==2)||(a==0&&(b==0||b==1||b==2||b==3))  %判断(a,b)是否符合限定情况
       for j=1:k                      %判断是否此岸a,b,c与之前有重复，如果是，结束此次循环，重新选择乘船方案
           if a==z(j,1)&&b==z(j,2)&&c==z(j,3)
               if m(k)~=5             %决策方案只有5种，所以m(k)<=5，
                  m(k)=m(k)+1;        %因为有重复，所以换下一种决策方案
               else                               
                  while (m(k)==5)&&(k>1)  
                       k=k-1;                %回溯，这一步骤已经把所有决策取尽，无可用解法，于是将后退一步，同时换下一种决策方案
                  end                     %while循环的目的是防止前面几步的决策都是5，导致k=k-1,m(k)=m(k)+1后数组越界，一直找到前面不是m(k)=5的步骤
                  m(k)=m(k)+1;
               end
               p=1;
               break;
           else
               p=0;
           end
       end    
       if p==1            %程序在跳出内层for循环之后，因为要换成决策方案，所以同时跳出，直接进入下一次while循环，
           continue;
       end
       if a==0&&b==0     %判断是否达到目标情况
          answer=1;
          fprintf('Successfully found!\n每一次的此岸人员分布：商人   仆人\n')
          for i=1:100
             fprintf('       第%2d次         %d     %d \n',i,z(i,1),z(i,2))
             if z(i,1)==0&&z(i,2)==0
                break;
             end
          end           %如果不是，进入下一步骤，计算z(k+2)
          if m(k)~=5
             m(k)=m(k)+1;        %这是正常的进入下一次，所以仍从d1乘船决策1开始
          else
               while (m(k)==5)&&(k>1)   
                  k=k-1;
               end;
               m(k)=m(k)+1;
          end
          continue;
       else             
           k=k+1;         %如果不是，进入下一步骤，计算z(k+2)
           m(k)=1;        %这是正常的进入下一次，所以仍从d1乘船决策1开始
           continue;       
       end
    else
        if m(k)~=5
           m(k)=m(k)+1;    %如果没有符合限定情况，结束该次循环，改变上一次的乘船方案
        else
           while (m(k)==5)&&(k>1)   
                  k=k-1;
           end        
           m(k)=m(k)+1;   %回溯，这一步骤已经把所有决策取尽，无可用解法，于是将后退一步，同时换下一种决策方案
        continue;
        end
    end
end
if answer==0&&flag==0
    fprintf('   No Answer!\n')
end
